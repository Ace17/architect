/**
 * @brief Misc abstract utility functions.
 * @author Sebastien Alaiwan
 * @date 2009-05-20
 */

// Copyright (C) 2015 - Sebastien Alaiwan
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import std.algorithm;
import std.string;
import std.traits;
import core.exception;

template swap(T)
{
  void swap(ref T t1, ref T t2)
  {
    T tmp = t1;
    t1 = t2;
    t2 = tmp;
  }
}

template order(T)
{
  void order(ref T a, ref T b)
  {
    if(a > b)
      swap(a, b);
  }
}

T sum(T)(T[] vals)
{
  T r = 0;
  foreach(t; vals)
  {
    r += t;
  }
  return r;
}

T mean(T)(T[] vals, T[] coeffs)
{
  T r = 0;
  foreach(i, ref t; vals)
  r += vals[i] * coeffs[i];
  r /= sum(coeffs);
  return r;
}

T clamp(T)(T val, T minVal, T maxVal)
{
  return min(maxVal, max(minVal, val));
}

T blend(T)(T val1, T val2, float factor)
{
  factor = clamp(factor, 0.0f, 1.0f);
  return (val1 * (1.0f - factor) + val2 * factor);
}

T round_div(T)(T number, T divisor)
{
  return (number + divisor/2) / divisor;
}

T pop(T)(ref T[] array)
{
  auto head = array[0];
  array = array[1..$];
  return head;
}

T last(T)(T[] array)
{
  return array[$-1];
}

string[] explode(string input, char separator)
{
  string[] ret;
  string token;
  foreach(c; input)
  {
    if(c == separator)
    {
      ret ~= token;
      token.length = 0;
    }
    else
      token ~= c;
  }

  if(token.length > 0)
    ret ~= token;
  return ret;
}

template array_remove(T)
{
  void array_remove(ref T[] tab, uint iIndex)
  {
    assert(iIndex >= 0);
    assert(iIndex < tab.length);

    for(int i=iIndex; i < tab.length-1; ++i)
      tab[i] = tab[i+1];

    tab.length = tab.length - 1;
  }
}

template array_insert(T)
{
  void array_insert(ref T[] tab, T val, uint iInsertAt)
  {
    assert(iInsertAt >= 0);
    assert(iInsertAt <= tab.length);

    tab.length = tab.length + 1;

    for(auto i=tab.length-1; i > iInsertAt; --i)
      tab[i] = tab[i-1];
    tab[iInsertAt] = val;

  }
}

template array_pop(T)
{
  T array_pop(ref T[] tab)
  {
    T r = tab[0];
    tab = tab[1..$];
    return r;
  }
}

uint array_find(T)(T[] tab, T what)
{
  foreach(i, element; tab)
  {
    if(element == what)
      return cast(uint)i;
  }

  return cast(uint)tab.length;
}


unittest
{
  static auto square(int n)
  {
    return n * n;
  }
  assertEquals([1, 4, 9, 16], mapArray!square([1, 2, 3, 4]));

  static auto multiply(int a, int b)
  {
    return a * b;
  }
  assertEquals([3, 6, 9, 12], mapArray!multiply([1, 2, 3, 4], 3));
}

ReturnType!F[] mapArray(alias F, T, ARGS...)(in T[] input, ARGS args)
{
  ReturnType!F[] r;
  foreach(element; input)
    r ~= F(element, args);
  return r;
}

U[] mapArrayDg(T, U)(in T[] input, U delegate(in T) fn)
{
  U[] r;
  foreach(e; input)
    r ~= fn(e);
  return r;
}

template sign(T)
{
  T sign(T f)
  {
    if(f >= cast(T)(0))
      return cast(T)(1);
    else
      return cast(T)(-1);
  }
}

void ensure(bool condition, string msg)
{
  if(!condition)
    throw new Exception(msg);
}

public static void assertEquals(S, T)(S s, T t,
    string file = __FILE__,
    size_t line = __LINE__)
{
  if (s != t) {
    throw new core.exception.AssertError(
        format("Expected: '%s', but was: '%s'", s, t),
        file, line);
  }
}

// vim: ts=2 sw=2 expandtab syntax=d
