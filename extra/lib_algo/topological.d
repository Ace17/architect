/**
 * @file topological.d
 * @author Sebastien Alaiwan
 * @date 2015-01-24
 */

// Copyright (C) 2015 - Sebastien Alaiwan
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import std.stdio;
import std.string;
import std.algorithm;
import misc;

unittest
{
  int[] getChildren(int i)
  {
    auto child1 = i*2;
    auto child2 = (i+1)*2;

    int[] r;
    if(child1 <= 10)
      r ~= child1;
    if(child2 <= 10)
      r ~= child2;
    return r;
  }

  void assertSorted(int[] tab,
      string file = __FILE__,
      size_t line = __LINE__)
  {
    int[][int] parents;
    bool[int] wasVisited;

    foreach(child; tab)
      parents[child] = [];

    foreach(parent; tab)
    {
      wasVisited[parent] = false;
      foreach(child; getChildren(parent))
        parents[child] ~= parent;
    }

    foreach(child; tab)
    {
      foreach(parent; parents[child])
      {
        if (!wasVisited[parent])
          throw new core.exception.AssertError(
              format("Not sorted: '%s' (parent) was not visited before '%s' (child) (%s)", parent, child, tab),
              file, line);
      }
      wasVisited[child] = true;
    }
  }

  assertSorted([1,3,2,4,5,6,7,8,9,10]);
  assertSorted(topologicalSort([10,9,8,7,6,5,4,3,2,1], &getChildren));
  assertSorted(topologicalSort([1,3,2,10,9,8,7,6,5,4], &getChildren));
}

T[] topologicalSort(T)(T[] input, T[] delegate(T) getChildren)
{
  bool[T] markedItems;
  bool[T] tempMarkedItems;

  T[] result;

  void visit(T item)
  {
    if(item in tempMarkedItems)
      return; // cycle detected
    if(item in markedItems)
      return;
    tempMarkedItems[item] = true;

    foreach(child; getChildren(item))
      visit(child);

    tempMarkedItems.remove(item);
    markedItems[item] = true;

    result ~= item;
  }

  foreach(item; input)
  {
    if(item !in markedItems)
      visit(item);
  }

  return result.reverse;
}

