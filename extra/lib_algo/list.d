/**
 * @brief List container. Used to ease porting from C++.
 * @author Sebastien Alaiwan
 * @date 2011-11-06
 */

// Copyright (C) 2015 - Sebastien Alaiwan
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import std.stdio;
import std.conv;

class list(T)
{
public:
  this()
  {
    m_pLastNode = &m_LastNode;
    m_pFirstNode = &m_FirstNode;

    m_pFirstNode.pPrev = null;
    m_pLastNode.pNext = null;

    link(m_pFirstNode, m_pLastNode);
  }

  alias list!T ListType;

  class iterator
  {
  private:
    NODE* m_pNode;
    ListType parent;

  public:
    ListType.iterator clone()
    {
      auto i_new = new list!(T).iterator(parent);
      i_new.m_pNode = m_pNode;
      return i_new;
    }

    this(ListType p_parent)
    {
      parent = p_parent;
      m_pNode = p_parent.m_pFirstNode.pNext;
    }

    T Get()
    {
      return m_pNode.data;
    }

    override bool opEquals(Object o)
    {
      iterator i = cast(iterator)o;
      return m_pNode is i.m_pNode;
    }

    void opPostInc()
    {
      m_pNode = m_pNode.pNext;
    }
  }

  int size() const
  {
    return m_iSize;
  }

  iterator begin()
  {
    iterator i = new iterator(this);
    return i;
  }

  iterator end()
  {
    iterator i = new iterator(this);
    i.m_pNode = m_pLastNode;
    return i;
  }

  bool empty() const
  {
    return size() == 0;
  }

  T back()
  {
    assert(m_iSize > 0);
    return m_pLastNode.pPrev.data;
  }

  T front()
  {
    assert(m_iSize > 0);
    return m_pFirstNode.pNext.data;
  }

  void push_front(T t)
  {
    NODE* pNew = new NODE;
    pNew.data = t;
    insert(m_pFirstNode, m_pFirstNode.pNext, pNew);
  }

  void push_back(T t)
  {
    NODE* pNew = new NODE;
    pNew.data = t;
    insert(m_pLastNode.pPrev, m_pLastNode, pNew);
  }

  void pop_front()
  {
    assert(m_iSize > 0);
    remove(m_pFirstNode.pNext);
  }

  void pop_back()
  {
    assert(m_iSize > 0);
    remove(m_pLastNode.pPrev);
  }

  void erase(iterator i)
  {
    remove(i.m_pNode);
  }

  void print_list(NODE* pBeforeFirst, NODE* pAfterLast)
  {
    NODE* pNode = pBeforeFirst.pNext;
    while(pNode != pAfterLast)
    {
      write(pNode.data, " ");
      pNode = pNode.pNext;
    }
  }

  // pBeforeFirst
  // |
  //( )->[2]->[7]->[3]->[4]->[1]->[9]->( )
  //                     |              |
  //                     pMiddle        pAfterLast
  void split(NODE* pBeforeFirst, NODE* pAfterLast, out NODE* pMiddle)
  {
    assert(pBeforeFirst != null);
    assert(pAfterLast != null);
    assert(pBeforeFirst.pNext != pAfterLast);

    int i=0;
    NODE* pNode = pBeforeFirst.pNext;
    while(pNode != pAfterLast)
    {
      pNode = pNode.pNext;
      i++;
    }

    int j=0;
    pMiddle = pBeforeFirst.pNext;
    while(pMiddle != pAfterLast && j < i/2)
    {
      pMiddle = pMiddle.pNext;
      j++;
    }
    assert(pMiddle != pAfterLast);
  }

  void merge(NODE* pBF1, NODE* pAL1, NODE* pBF2, NODE* pAL2)
  {
    // position pointers on first element of each list
    NODE* p1 = pBF1.pNext;
    NODE* p2 = pBF2.pNext;

    NODE* merged_head = pBF1;

    while(1)
    {
      // update list emptiness
      bool not_empty1 = (p1 != pAL1);
      bool not_empty2 = (p2 != pAL2);

      bool bTakeFromList1 = true;

      if(not_empty1 && not_empty2)
      {
        // no list is empty, take smallest of both heads
        if(p1.data <= p2.data)
        {
          bTakeFromList1 = true;
        }
        else
        {
          bTakeFromList1 = false;
        }
      }
      else if(not_empty1)
      {
        bTakeFromList1 = true;
      }
      else if(not_empty2)
      {
        bTakeFromList1 = false;
      }
      else
      {
        // both lists are empty, exit!
        break;
      }

      if(bTakeFromList1)
      {
        // add smallest head to list
        link(merged_head, p1);

        // update head
        merged_head = p1;

        // advance list pointer
        p1 = p1.pNext;
      }
      else
      {
        // add smallest head to list
        link(merged_head, p2);

        // update head
        merged_head = p2;

        // advance list pointer
        p2 = p2.pNext;
      }
    }

    link(merged_head, pAL2);
  }

  /**
   * @brief Sort a list of nodes.
   *
   * @param pBeforeFirst pointer to the sentinel directly on the left of the first element.
   * @param pAfterLast pointer to the sentinel directly on the right of the last element.
   */
  void internal_sort(NODE* pBeforeFirst, NODE* pAfterLast)
  {
    assert(pBeforeFirst != null);
    assert(pAfterLast != null);

    // empty list
    if(pBeforeFirst.pNext == pAfterLast)
      return;

    // one element list
    if(pBeforeFirst.pNext == pAfterLast.pPrev)
      return;

    NODE* pMiddle;
    split(pBeforeFirst, pAfterLast, pMiddle);

    NODE bf1, al1;
    link(&bf1, pBeforeFirst.pNext);
    bf1.pPrev = null;
    link(pMiddle.pPrev, &al1);
    al1.pNext = null;

    NODE bf2, al2;
    link(&bf2, pMiddle);
    bf2.pPrev = null;
    link(pAfterLast.pPrev, &al2);
    al2.pNext = null;

    internal_sort(&bf1, &al1);
    internal_sort(&bf2, &al2);

    merge(&bf1, &al1, &bf2, &al2);

    link(pBeforeFirst, bf1.pNext);
    link(al2.pPrev, pAfterLast);
  }

  void sort()
  {
    internal_sort(m_pFirstNode, m_pLastNode);
  }

  void clear()
  {
    while(size() > 0)
      pop_front();
  }

  void merge(list!(T) lt)
  {
    if(lt.empty())
      return;
    assert(0); // not implemented
  }

  int const_foreach(int delegate(ref const(T)) dg) const
  {
    const(NODE)* pNode = m_pFirstNode.pNext;
    while(pNode !is m_pLastNode)
    {
      auto result = dg(pNode.data);
      if(result)
        return result;
      pNode = pNode.pNext;
    }
    return 0;
  }

  int opApply(int delegate(ref T) dg)
  {
    NODE* pNode = m_pFirstNode.pNext;
    while(pNode !is m_pLastNode)
    {
      auto result = dg(pNode.data);
      if(result)
        return result;
      pNode = pNode.pNext;
    }
    return 0;
  }

  list!(T) clone()
  {
    list!(T) n = new list!(T);
    list!(T) s = cast(list!(T))this;
    foreach(t; s)
    {
      n.push_back(t);
    }
    return n;
  }

  override string toString() const
  {
    string s;
    s ~= "[";

    const(NODE)* pNode = m_pFirstNode.pNext;

    while(pNode !is m_pLastNode)
    {
      if(pNode!=m_pFirstNode.pNext)
        s ~= ", ";
      s ~= to!string(pNode.data);
      pNode = pNode.pNext;
    }
    s ~= "]";

    return s;
  }

private:
  struct NODE
  {
    T data;
    NODE* pPrev;
    NODE* pNext;
  }

  NODE m_FirstNode;
  NODE m_LastNode;
  NODE* m_pLastNode;
  NODE* m_pFirstNode;

  // updated when the list is changed
  int m_iSize;

  void link(NODE* pPrev, NODE* pNext)
  {
    pPrev.pNext = pNext;
    pNext.pPrev = pPrev;
  }

  void insert(NODE* pPrev, NODE* pNext, NODE* pNew)
  {
    assert(pPrev.pNext is pNext);
    assert(pNext.pPrev is pPrev);

    link(pPrev, pNew);
    link(pNew, pNext);

    m_iSize ++;
  }

  void remove(NODE* pNode)
  {
    assert(pNode !is m_pFirstNode);
    assert(pNode !is m_pLastNode);

    link(pNode.pPrev, pNode.pNext);

    delete pNode;
    m_iSize--;
  }
}

struct linked_node(T)
{
public:
  this(T p_owner)
  {
    prev = next = null;
    owner = p_owner;
  }

  void remove()
  {
    prev.next = this.next;
    if(next)
      next.prev = this.prev;
  }

  void insert_after(linked_node!T* newNode)
  {
    auto nodeAfter = this.next;

    // link newNode (before) to nodeAfter (After)
    newNode.next = nodeAfter;
    if(nodeAfter != null)
      nodeAfter.prev = newNode;

    // link us (before) to newNode (after)
    newNode.prev = &this;
    this.next = newNode;
  }

  int opApply(int delegate(ref T) dg)
  {
    auto pCurr = next;
    while(pCurr != null)
    {
      auto pNext = pCurr.next;
      dg(pCurr.owner);
      pCurr = pNext;
    }
    return 0;
  }

private:
  linked_node!T* prev = null;
  linked_node!T* next = null;

  T owner;
}

// vim: ts=2 sw=2 expandtab syntax=d
