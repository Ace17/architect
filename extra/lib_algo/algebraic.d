/**
 * @file algebraic.d
 * @brief An implementation of an algebraic type, based on mixins.
 * @author Sebastien Alaiwan
 * @date 2014-07-19
 */

// Copyright (C) 2015 - Sebastien Alaiwan
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

import std.array;
import std.string;
import std.stdio;

unittest
{
  class C
  {
  }

  //writefln(CreateUnionType("Test", [ "int", "string" ]));
  mixin(CreateUnionType("Test", [ "int", "string", "C" ]));

  auto var1 = Test(4);
  auto var2 = Test("hello");
  var1 = var2;

  {
    const r = var1.visit!(
        (int yo) => 1,
        (string s) => 2,
        (C c) => 3
        )();
    assert(r == 2);
  }

  var2 = "hello";
  var2 = 39;

  const var3 = Test(33);

  {
    const r = var3.visit!(
        (int yo) => 1,
        (string s) => 2,
        (const C c) => 3
        )();
    assert(r == 1);
  }
}

string CreateUnionType(string name, string[] types)
{
  return format("alias Either!(%s) %s;", join(types, ","), name);
}

struct Either(Types...)
{
  this(T)(T val)
  {
    m_Type = mixin(format("Tag.T%s", T.stringof));
    mixin(format("m_v%s", TypeIndex!(T, Types))) = val;
  }

  void opAssign(T)(T val) if(!is(T == Either!Types))
  {
    m_Type = mixin(format("Tag.T%s", T.stringof));
    mixin(format("m_v%s", TypeIndex!(T, Types))) = val;
  }

  mixin(DeclareAliases!Types);
  mixin(DeclareDynamicVisit!Types);
  mixin(createVisitFunction!Types);

private:

  mixin(createInternalEnum!Types);

  Tag m_Type;

  union
  {
    mixin(createInternalUnion!Types);
  }
}

template TypeIndex(Needle, T, Types...)
{
  static if(is(T == Needle))
    const TypeIndex = 0;
  else
    const TypeIndex = 1 + TypeIndex!(Needle, Types);
}

string createVisitFunction(Types...)()
{
  string s;

  s ~= "auto visit(";

  foreach(i, T; Types)
  {
    if(i > 0)
      s ~= ", ";
    s ~= format("alias f%s", i);
  }

  s ~= ", this T";
  s ~= ")";
  s ~= "()";
  s ~= "\n";

  // function body
  s ~= "{\n";
  s ~= "  final switch(m_Type)";
  s ~= "  {\n";
  foreach(i, T; Types)
    s ~= format("case Tag.T%s: return f%s(m_v%s);", T.stringof, i, i);
  s ~= "  }\n";
  s ~= "}\n";

  return s;
}

string createInternalUnion(Types...)()
{
  string s;
  foreach(i, T; Types)
    s ~= format("T%s m_v%s;", i, i);

  return s;
}

string createInternalEnum(Types...)()
{
  string s;
  s ~= "enum Tag\n";
  s ~= "{\n";
  foreach(i, T; Types)
    s ~= format("T%s,", T.stringof);
  s ~= "}\n";

  return s;
}

string DeclareAliases(Types...)()
{
  string r;
  foreach(i, T; Types)
  {
    r ~= format("alias Types[%s] T%s;", i, i);
  }
  return r;
}

string DeclareDynamicVisit(Types...)()
{
  string r;
  r ~= "U visitDg(U)";

  // argument list
  r ~= "(";
  foreach(i, T; Types)
  {
    if(i > 0)
      r ~= ", ";
    r ~= format("U delegate(T%s) f%s", i, i);
  }
  r ~= ")";

  // function body
  r ~= "{";
  r ~= "  final switch(m_Type)";
  r ~= "  {";
  foreach(i, T; Types)
    r ~= format("case Tag.T%s: return f%s(m_v%s);", T.stringof, i, i);
  r ~= "  }";
  r ~= "}";

  return r;
}

